'''
  Eric C. Joyce, Stevens Institute of Technology, 2020

  You've run the automated viewpoint-collection version of 3dcamera.py inside Blender.
  Now you want to pick one or more of these snapshots to turn into a signature.
  This is the script for you.

  This script assumes the existence of the following files, for a given OBJECT, and
  for which 'X' is a snapshot/rendering number, an integer >= 0.
    ./dimensions/OBJECT/dimensions.X.dat  file containing a binary array (length 2) of the image width and image height
    ./depth/OBJECT/depth.X.dat            file containing a binary array of depth values
    ./K/OBJECT/K.X.dat                    file containing the 3(col)-by-3(row) intrinsic matrix in row-major order
    ./rgb/OBJECT/rgb.X.png                rendered bitmap of an object; corresponds to depth.X.buffer
    ./Rt/OBJECT/Rt.X.dat                  file containing the 3(col)-by-4(row) extrinsic matrix in row-major order

  Using these files, this script will create one .raw3d file for each descriptors called upon.

'''

import numpy as np
from numpy.linalg import inv
import os
import struct
import subprocess
import sys
from sklearn.neighbors import KDTree

def main():
	if len(sys.argv) < 3:
		usage()
		return

	targetObject = sys.argv[1]										#  Save the target object

	params = getParameters()
	if params['helpme'] or len(params['snapshots']) == 0:
		usage()
		return

	for index in params['snapshots']:								#  Make sure we have everything we need:
																	#  NOTE: masks are optional! There will not always be a mask!
		dimensionsFN = 'dimensions/' + targetObject + '/dimensions.' + str(index) + '.dat'
		if not os.path.exists(dimensionsFN):
			print('ERROR: Unable to find necessary file "' + dimensionsFN + '".')
			return
		depthFN = 'depth/' + targetObject + '/depth.' + str(index) + '.dat'
		if not os.path.exists(depthFN):
			print('ERROR: Unable to find necessary file "' + depthFN + '".')
			return
		KFN = 'K/' + targetObject + '/K.' + str(index) + '.dat'
		if not os.path.exists(KFN):
			print('ERROR: Unable to find necessary file "' + KFN + '".')
			return
		rgbFN = params['imgsrc'] + '/' + targetObject + '/' + params['imgsrc'] + '.' + str(index) + '.png'
		if not os.path.exists(rgbFN):
			print('ERROR: Unable to find necessary file "' + rgbFN + '".')
			return
		RtFN = 'Rt/' + targetObject + '/Rt.' + str(index) + '.dat'
		if not os.path.exists(KFN):
			print('ERROR: Unable to find necessary file "' + RtFN + '".')
			return

	for index in params['snapshots']:	#############################  For each snapshot

		#############################################################  Call feature extractor
		rgbFN = params['imgsrc'] + '/' + targetObject + '/' + params['imgsrc'] + '.' + str(index) + '.png'
		depthFN = 'depth/' + targetObject + '/depth.' + str(index) + '.dat'
		maskFN = 'masks/' + targetObject + '/mask.' + str(index) + '.png'

		args = ['./extract', '-Q', rgbFN]
		if not params['SIFT']:
			args += ['-SIFT', 'N']
		if not params['SURF']:
			args += ['-SURF', 'N']
		if not params['ORB']:
			args += ['-ORB', 'N']
		if not params['BRISK']:
			args += ['-BRISK', 'N']
		args += ['-D', depthFN]
		if os.path.exists(maskFN):
			args += ['-mask', maskFN]
		if params['BRISKcfg'] is not None:
			args += ['-BRISKcfg', params['BRISKcfg']]
		if params['ORBcfg'] is not None:
			args += ['-ORBcfg', params['ORBcfg']]
		if params['SIFTcfg'] is not None:
			args += ['-SIFTcfg', params['SIFTcfg']]
		if params['SURFcfg'] is not None:
			args += ['-SURFcfg', params['SURFcfg']]
		args += ['-e', str(params['erosion'])]
		if params['bkernel'] > 0:
			args += ['-bkernel', str(params['bkernel'])]
			args += ['-bmeth', str(params['bmeth'])]
		if params['verbose']:
			args.append('-v')
		output = subprocess.check_output(args)
		if params['verbose']:
			print(output)

		#############################################################  Recover necessary data from files generated by Blender-script
		dimensionsFN = 'dimensions/' + targetObject + '/dimensions.' + str(index) + '.dat'
		fh = open(dimensionsFN, 'rb')
		data = fh.read()
		w, h = struct.unpack('>II', data)							#  I pack BIG-ENDIAN
		if params['verbose']:
			print('>>> Object rendering is ' + str(w) + ' x ' + str(h))
		fh.close()

		depthFN = 'depth/' + targetObject + '/depth.' + str(index) + '.dat'
		fh = open(depthFN, 'rb')
		depth = np.fromfile(fh, '<f')								#  Blender packs LITTLE-ENDIAN
		depth = depth[::-1]											#  Reverse array
		depth = depth.reshape((h, w))
		depth = np.flip(depth, 1)									#  Flip horizontal
		if params['verbose']:
			print('>>> Read depth buffer from file. Shape is ' + str(depth.shape[1]) + ' x ' + str(depth.shape[0]))
		fh.close()

		KFN = 'K/' + targetObject + '/K.' + str(index) + '.dat'
		fh = open(KFN, 'rb')
		K = np.fromfile(fh, '>f')									#  I pack BIG-ENDIAN
		K = K.reshape((3, 3))
		if params['verbose']:
			print('>>> Read intrinsic matrix from file:')
			print(K)
		K_inv = inv(K)
		fh.close()

		RtFN = 'Rt/' + targetObject + '/Rt.' + str(index) + '.dat'
		fh = open(RtFN, 'rb')
		Rt = np.fromfile(fh, '>f')									#  I pack BIG-ENDIAN
		Rt = Rt.reshape((4, 4))
		if params['verbose']:
			print('>>> Read extrinsic matrix from file:')
			print(Rt)
		Rt_inv = inv(Rt)
		fh.close()

		#############################################################  Retrieve features and 2D points from files
		#  FOLLOW ALPHABETICAL ORDER, AS USED IN pnp.cpp

		features = []

		if params['BRISK']:
			if not os.path.exists('features.brisk'):
				print('ERROR: Expected to find local file named "features.brisk".')
				return
			fh = open('features.brisk', 'rb')
			data = fh.read()
			#  BRISK VECTOR IS IN UCHARs!
			#  Read x, y, size, angle, response, octave, 64, BRISK[0], BRISK[1], ..., BRISK[n-1]
			#       f  f  f     f      f         i       uc  uc        uc             uc
			packstr = '<fffffIB' + 'B'*64								#  'extract' writes LITTLE-ENDIAN
			ctr = 0
			for i in range(0, len(data), 89):
				featuredata = struct.unpack(packstr, data[i:i+89])
				x = featuredata[0]
				y = featuredata[1]
				size = featuredata[2]
				angle = featuredata[3]
				response = featuredata[4]
				octave = featuredata[5]
				veclen = featuredata[6]
																	#  0 in [0] stands for BRISK
				feature  = [0, x, y, None, size, angle, response, octave, veclen]
				feature += featuredata[7:]
				features.append( feature )
				ctr += 1
			fh.close()
			if params['verbose']:
				print('>>> Read ' + str(ctr) + ' BRISK features')

		if params['ORB']:
			if not os.path.exists('features.orb'):
				print('ERROR: Expected to find local file named "features.orb".')
				return
			fh = open('features.orb', 'rb')
			data = fh.read()
			#  ORB VECTOR IS IN UCHARs!
			#  Read x, y, size, angle, response, octave, 32, ORB[0], ORB[1], ..., ORB[n-1]
			#       f  f  f     f      f         i       uc  uc      uc           uc
			packstr = '<fffffIB' + 'B'*32							#  'extract' writes LITTLE-ENDIAN
			ctr = 0
			for i in range(0, len(data), 57):
				featuredata = struct.unpack(packstr, data[i:i+57])
				x = featuredata[0]
				y = featuredata[1]
				size = featuredata[2]
				angle = featuredata[3]
				response = featuredata[4]
				octave = featuredata[5]
				veclen = featuredata[6]
																	#  1 in [0] stands for ORB
				feature  = [1, x, y, None, size, angle, response, octave, veclen]
				feature += featuredata[7:]
				features.append( feature )
				ctr += 1
			fh.close()
			if params['verbose']:
				print('>>> Read ' + str(ctr) + ' ORB features')

		if params['SIFT']:
			if not os.path.exists('features.sift'):
				print('ERROR: Expected to find local file named "features.sift".')
				return
			fh = open('features.sift', 'rb')
			data = fh.read()
			#  Read x, y, size, angle, response, octave, 128, SIFT[0], SIFT[1], ..., SIFT[n-1]
			#       f  f  f     f      f         i       uc   f        f             f
			packstr = '<fffffIB' + 'f'*128							#  'extract' writes LITTLE-ENDIAN
			ctr = 0
			for i in range(0, len(data), 537):
				featuredata = struct.unpack(packstr, data[i:i+537])
				x = featuredata[0]
				y = featuredata[1]
				size = featuredata[2]
				angle = featuredata[3]
				response = featuredata[4]
				octave = featuredata[5]
				veclen = featuredata[6]
																	#  2 in [0] stands for SIFT
				feature  = [2, x, y, None, size, angle, response, octave, veclen]
				feature += featuredata[7:]
				features.append( feature )
				ctr += 1
			fh.close()
			if params['verbose']:
				print('>>> Read ' + str(ctr) + ' SIFT features')

		if params['SURF']:
			if not os.path.exists('features.surf'):
				print('ERROR: Expected to find local file named "features.surf".')
				return
			fh = open('features.surf', 'rb')
			data = fh.read()
			#  Read x, y, size, angle, response, octave, 64, SURF[0], SURF[1], ..., SURF[n-1]
			#       f  f  f     f      f         i       uc  f        f             f
			packstr = '<fffffIB' + 'f'*64							#  'extract' writes LITTLE-ENDIAN
			ctr = 0
			for i in range(0, len(data), 281):
				featuredata = struct.unpack(packstr, data[i:i+281])
				x = featuredata[0]
				y = featuredata[1]
				size = featuredata[2]
				angle = featuredata[3]
				response = featuredata[4]
				octave = featuredata[5]
				veclen = featuredata[6]
																	#  3 in [0] stands for SURF
				feature  = [3, x, y, None, size, angle, response, octave, veclen]
				feature += featuredata[7:]
				features.append( feature )
				ctr += 1
			fh.close()
			if params['verbose']:
				print('>>> Read ' + str(ctr) + ' SURF features')

		#############################################################  Consolidate features with their 3D points

		valid_features = []
		for i in range(0, len(features)):
			pt3d = backproject( K_inv, Rt_inv, depth, (features[i][1], features[i][2]), params['verbose'] )

			if pt3d is not None:
				valid_features.append( [features[i][0],  pt3d[0], pt3d[1], pt3d[2]] + features[i][4:] )
				project(K, Rt, pt3d, params['verbose'])

		#############################################################  Write descriptor output(s)
		#  FOLLOW ALPHABETICAL ORDER, AS USED IN pnp.cpp

		if params['BRISK']:
			ctr = 0
			for feature in valid_features:
				if feature[0] == 0:									#  BRISK = 0
					ctr += 1
			if ctr > 0:												#  Any BRISK features to write?
				fh = open('brisk.' + str(index) + '.raw3d', 'wb')
				for feature in valid_features:
					if feature[0] == 0:								#  BRISK = 0
																	#  'extract' writes LITTLE-ENDIAN
						packstr = '<BffffffIB' + 'B'*64				#  length 64
						fh.write(struct.pack(packstr, *feature))
				fh.close()

		if params['ORB']:
			ctr = 0
			for feature in valid_features:
				if feature[0] == 1:									#  ORB = 1
					ctr += 1
			if ctr > 0:												#  Any ORB features to write?
				fh = open('orb.' + str(index) + '.raw3d', 'wb')
				for feature in valid_features:
					if feature[0] == 1:								#  ORB = 1
																	#  'extract' writes LITTLE-ENDIAN
						packstr = '<BffffffIB' + 'B'*32				#  length 32
						fh.write(struct.pack(packstr, *feature))
				fh.close()

		if params['SIFT']:
			ctr = 0
			for feature in valid_features:
				if feature[0] == 2:									#  SIFT = 2
					ctr += 1
			if ctr > 0:												#  Any SIFT features to write?
				fh = open('sift.' + str(index) + '.raw3d', 'wb')
				for feature in valid_features:
					if feature[0] == 2:								#  SIFT = 2
																	#  'extract' writes LITTLE-ENDIAN
						packstr = '<BffffffIB' + 'f'*128			#  length 128
						fh.write(struct.pack(packstr, *feature))
				fh.close()

		if params['SURF']:
			ctr = 0
			for feature in valid_features:
				if feature[0] == 3:									#  SURF = 3
					ctr += 1
			if ctr > 0:												#  Any SURF features to write?
				fh = open('surf.' + str(index) + '.raw3d', 'wb')
				for feature in valid_features:
					if feature[0] == 3:								#  SURF = 3
																	#  'extract' writes LITTLE-ENDIAN
						packstr = '<BffffffIB' + 'f'*64				#  length 64
						fh.write(struct.pack(packstr, *feature))
				fh.close()

	#################################################################  Feature extraction is done.
																	#  Consolidate and write the signature.

	minx = float('inf')												#  Unless we're given a bounding box
	maxx = float('-inf')											#  find one

	miny = float('inf')
	maxy = float('-inf')

	minz = float('inf')
	maxz = float('-inf')

	featurePoints = []												#  List of tuples:
																	#  (desc, x, y, z, size, angle, response, octave, descLen, n...)
																	#     B   f  f  f    f      f       f        I       B     f
	if params['verbose']:
		print('>>> Reading 3D feature snapshots...')

	for index in params['snapshots']:	#############################  For each snapshot
		for descriptor in ['sift', 'orb', 'brisk', 'surf']:
			filename = descriptor + '.' + str(index) + '.raw3d'
			if os.path.exists(filename):
				if params['verbose']:
					print('    ' + filename)
				fh = open(filename, 'rb')							#  Open for binary reading
				data = fh.read()									#  Read all file data

				if descriptor == 'sift':
					recordsize = 542
					packstr = '<BffffffIB' + 'f'*128				#  .raw3d written LITTLE-ENDIAN, so read LITTLE-ENDIAN

				elif descriptor == 'orb':
					recordsize = 62
					packstr = '<BffffffIB' + 'B'*32					#  .raw3d written LITTLE-ENDIAN, so read LITTLE-ENDIAN

				elif descriptor == 'brisk':
					recordsize = 94
					packstr = '<BffffffIB' + 'B'*64					#  .raw3d written LITTLE-ENDIAN, so read LITTLE-ENDIAN

				elif descriptor == 'surf':
					recordsize = 286
					packstr = '<BffffffIB' + 'f'*64					#  .raw3d written LITTLE-ENDIAN, so read LITTLE-ENDIAN

				for i in range(0, len(data), recordsize):
					record = struct.unpack(packstr, data[i:i+recordsize])

					desc = record[0]
					x = record[1]
					y = record[2]
					z = record[3]
					if x < minx:									#  Update X bounds
						minx = x
					if x > maxx:
						maxx = x

					if y < miny:									#  Update Y bounds
						miny = y
					if y > maxy:
						maxy = y

					if z < minz:									#  Update Z bounds
						minz = z
					if z > maxz:
						maxz = z

					size = record[4]
					angle = record[5]
					response = record[6]
					octave = record[7]
					descLen = record[8]

					vec = list(record[9:])

					featurePoints.append( tuple( [desc, x, y, z, size, angle, response, octave, descLen] + vec ) )

				fh.close()

																	#  Sort by strength of response
	featurePoints = sorted(featurePoints, key=lambda x: x[6], reverse=True)
	originalLength = len(featurePoints)								#  Save original number of points

	if params['verbose']:
		print('>>> Consolidated ' + str(len(featurePoints)) + ' feature points')

	if params['epsilon'] is not None:								#  Limit features by distance

		data = np.array( [x[1:4] for x in featurePoints] )			#  N feature points in 3 dimensions
		tree = KDTree(data, leaf_size=2)							#  Build a tree

		markedForDeath = []											#  Indices of feature-points to be removed because
																	#  they are within epsilon of a more responsive feature.
		for feature in featurePoints:
			indices = tree.query_radius(np.array( [feature[1:4]] ), r=params['epsilon'])
			for index in indices[0][1:]:
				if index not in markedForDeath:
					markedForDeath.append(index)

		#  FOLLOW ALPHABETICAL ORDER, AS USED IN pnp.cpp

		usedBRISK = False
		usedORB = False
		usedSIFT = False
		usedSURF = False
		reducedFeaturePoints = []										#  New list, without the ones we've marked for omission
		for i in range(0, len(featurePoints)):
			if i not in markedForDeath:
				reducedFeaturePoints.append(featurePoints[i])
				if featurePoints[i][0] == 0:
					usedBRISK = True
				elif featurePoints[i][0] == 1:
					usedORB = True
				elif featurePoints[i][0] == 2:
					usedSIFT = True
				elif featurePoints[i][0] == 3:
					usedSURF = True

		featurePoints = reducedFeaturePoints[:]							#  Over-write

	if params['max'] is not None:										#  Limit features by count

		#  FOLLOW ALPHABETICAL ORDER, AS USED IN pnp.cpp

		usedBRISK = False
		usedORB = False
		usedSIFT = False
		usedSURF = False
																		#  New list, without the ones we've marked for omission
		reducedFeaturePoints = [ featurePoints[i] for i in range(0, min(params['max'], len(featurePoints))) ]
		for i in range(0, len(reducedFeaturePoints)):
			if reducedFeaturePoints[i][0] == 0:
				usedBRISK = True
			elif reducedFeaturePoints[i][0] == 1:
				usedORB = True
			elif reducedFeaturePoints[i][0] == 2:
				usedSIFT = True
			elif reducedFeaturePoints[i][0] == 3:
				usedSURF = True

		featurePoints = reducedFeaturePoints[:]							#  Over-write

	if params['verbose']:
		print('>>> ' + str(len(featurePoints)) + ' feature-points of ' + str(originalLength) + ' remain after consolidation.')
		if usedBRISK:
			print('    BRISK was used.')
		if usedORB:
			print('    ORB was used.')
		if usedSIFT:
			print('    SIFT was used.')
		if usedSURF:
			print('    SURF was used.')

	if params['header'] is not None:
		fh = open(params['header'], 'r')
		header = [ord(x) for x in fh.read()]
		fh.close()
		if len(header) > 512:
			header = header[:512]
		else:
			for i in range(len(header), 512):
				header.append(0)
	else:
		header = [0 for i in range(0, 512)]

	fh = open('features.3df', 'wb')
	packstr = '<' + 'B'*512											#  Write LITTLE-ENDIAN for C++ programs to read
	fh.write(struct.pack(packstr, *header))							#  Write the 512-byte header

	packstr = '<I'													#  Write LITTLE-ENDIAN for C++ programs to read
	fh.write(struct.pack(packstr, len(featurePoints)))				#  Write D = total number of feature-points

	packstr = '<I'													#  Write LITTLE-ENDIAN for C++ programs to read
	fh.write(struct.pack(packstr, 0))								#  Write E = total number of exclusivity-constraints (for now, 0)

	packstr = '<B'													#  Write LITTLE-ENDIAN for C++ programs to read
	fh.write(struct.pack(packstr, 4))								#  Write N = total number of descriptor/detectors
																	#  (4 for now: SIFT, ORB, BRISK, SURF)
	packstr = '<B'													#  Used to hold N bools: does this file make use of these descriptors?
	boolArr = 0

	#  FOLLOW ALPHABETICAL ORDER, AS USED IN pnp.cpp

	if usedBRISK:													#  Used BRISK?
		boolArr |= 1												#  | 2^0
	if usedORB:														#  Used ORB?
		boolArr |= 2												#  | 2^1
	if usedSIFT:													#  Used SIFT?
		boolArr |= 4												#  | 2^2
	if usedSURF:													#  Used SURF?
		boolArr |= 8												#  | 2^3

	fh.write(struct.pack(packstr, boolArr))							#  Write LITTLE-ENDIAN for C++ programs to read

	packstr = '<fff'												#  Write LITTLE-ENDIAN for C++ programs to read
	fh.write(struct.pack(packstr, minx, miny, minz))				#  Write min-min-min bounding box corner
	fh.write(struct.pack(packstr, maxx, maxy, maxz))				#  Write max-max-max bounding box corner
	if params['verbose']:
		print('>>> Bounding box min-min-min: ' + str(minx) + ', ' + str(miny) + ', ' + str(minz))
		print('>>> Bounding box max-max-max: ' + str(maxx) + ', ' + str(maxy) + ', ' + str(maxz))

	#  FOLLOW ALPHABETICAL ORDER, AS USED IN pnp.cpp
																	#  Write each of the D feature-points
	for feature in featurePoints:									#  in order of decreasing response
		if feature[0] == 0:
			packstr = '<BffffffIB' + 'B'*64							#  BRISK, length 64
			fh.write(struct.pack(packstr, *feature))
		elif feature[0] == 1:
			packstr = '<BffffffIB' + 'B'*32							#  ORB, length 32
			fh.write(struct.pack(packstr, *feature))
		elif feature[0] == 2:
			packstr = '<BffffffIB' + 'f'*128						#  SIFT, length 128
			fh.write(struct.pack(packstr, *feature))
		elif feature[0] == 3:
			packstr = '<BffffffIB' + 'f'*64							#  SURF, length 64
			fh.write(struct.pack(packstr, *feature))

	#  Write each of the E exclusivity constraints:
	#    these are pairs of indices: see this one--->can't see that one & vice versa
	#    (the assumption is that, otherwise, you MIGHT see any two pairs)

	fh.close()

	fh = open('features3d.ply', 'w')
	fh.write('ply\n')
	fh.write('format ascii 1.0\n')
	fh.write('comment https://github.com/EricCJoyce\n')
	fh.write('element vertex ' + str(len(featurePoints)) + '\n')
	fh.write('property float x\n')
	fh.write('property float y\n')
	fh.write('property float z\n')
	fh.write('property uchar red\n')
	fh.write('property uchar green\n')
	fh.write('property uchar blue\n')
	fh.write('end_header\n')

	#  FOLLOW ALPHABETICAL ORDER, AS USED IN pnp.cpp

	for feature in featurePoints:
		fh.write(str(feature[1]) + ' ' + str(feature[2]) + ' ' + str(feature[3]))
		if feature[0] == 0:											#  BRISK is blue
			fh.write(' 0 0 255\n')
		elif feature[0] == 1:										#  ORB is green
			fh.write(' 0 255 0\n')
		elif feature[0] == 2:										#  SIFT is red
			fh.write(' 255 0 0\n')
		elif feature[0] == 3:										#  SURF is yellow
			fh.write(' 255 255 0\n')
	fh.close()

	#  Clean up
	if os.path.exists('features.brisk'):
		os.remove('features.brisk')
	if os.path.exists('features.orb'):
		os.remove('features.orb')
	if os.path.exists('features.sift'):
		os.remove('features.sift')
	if os.path.exists('features.surf'):
		os.remove('features.surf')

	markedForDeath = [file for file in os.listdir('.') if file.endswith('.raw3d')]
	for file in markedForDeath:
		os.remove(file)

	return

def project(K, Rt, point3D, verbose=False):
	pt = np.array( [point3D[0], point3D[1], point3D[2], 1.0] )
	pt = pt.reshape((4, 1))
	pixel = K.dot(Rt[0:3,:]).dot(pt)
	pixel = (pixel[0][0] / pixel[2][0], pixel[1][0] / pixel[2][0])
	if verbose:
		print('   (' + str(point3D[0]) + ', ' + str(point3D[1]) + ', ' + str(point3D[2]) + ') projects to (' + \
		               str(pixel[0]) + ', ' + str(pixel[1]) + ')\n')
	return pixel

def backproject(K_inv, Rt_inv, depth, point2D, verbose=False):
	x = point2D[0]
	y = point2D[1]
	z = depth[ int(round(y)) ][ int(round(x)) ]
	if z == 65504.0:												#  If it's garbage, then ignore it.
		return None

	v = np.array( [x, y, 1.0] )
	v = v.reshape((3, 1))
	v = K_inv.dot(v)
	v *= z
	v = np.array( [v[0][0], v[1][0], v[2][0], 1.0] )
	v = v.reshape((4, 1))
	v = Rt_inv.dot(v)												#  This, finally, is the 3D point.

	if verbose:
		print('(' + str(x) + ', ' + str(y) + ') with depth ' + str(z) + \
			  ' backprojects to (' + str(v[0][0]) + ', ' + str(v[1][0]) + ', ' + str(v[2][0]) + ')')

	return (v[0][0], v[1][0], v[2][0])

def getParameters():
	params = {}														#  Parameter dictionary
	params['snapshots'] = []										#  Collect snapshot indices
	params['SIFT'] = True											#  Default is to use SIFT
	params['SURF'] = True											#  Default is to use SURF
	params['ORB'] = True											#  Default is to use ORB
	params['BRISK'] = True											#  Default is to use BRISK
	params['mask'] = None											#  Default is no additional mask (./extract already masks depth)
	params['erosion'] = 5											#  Default is to erode by 5 pixels
	params['BRISKcfg'] = None										#  Default to BRISK defaults
	params['ORBcfg'] = None											#  Default to ORB defaults
	params['SIFTcfg'] = None										#  Default to SIFT defaults
	params['SURFcfg'] = None										#  Default to SURf defaults
	params['bmeth'] = 'BOX'											#  Default is Box Filter
	params['bkernel'] = 0											#  Default is no blur
	params['header'] = None											#  Default to no header
	params['epsilon'] = None
	params['max'] = None											#  Default to None
	params['imgsrc'] = 'rgb'										#  Default is to use the rgb files
	params['verbose'] = False										#  Default is to shut up
	params['helpme'] = False										#  Default is to not display help

	argtarget = None												#  Current argument to be set
																	#  Permissible setting flags
	flags = ['-SIFT', '-SURF', '-ORB', '-BRISK', \
	         '-BRISKcfg', '-ORBcfg', '-SIFTcfg', '-SURFcfg', \
	         '-mask', '-erode', '-imgsrc', \
	         '-bmeth', '-bkernel', \
	         '-epsilon', '-max', '-h', \
	         '-v', \
	         '-?', '-help', '--help']

	for i in range(2, len(sys.argv)):
		if sys.argv[i] in flags:
			argtarget = sys.argv[i]
			if argtarget == '-v':
				params['verbose'] = True
			elif argtarget == '-?' or argtarget == '-help' or argtarget == '--help':
				params['helpme'] = True
		else:
			argval = sys.argv[i]

			if argtarget == '-SIFT':
				if argval == 'Y' or argval == 'y':
					params['SIFT'] = True
				else:
					params['SIFT'] = False
			elif argtarget == '-SURF':
				if argval == 'Y' or argval == 'y':
					params['SURF'] = True
				else:
					params['SURF'] = False
			elif argtarget == '-ORB':
				if argval == 'Y' or argval == 'y':
					params['ORB'] = True
				else:
					params['ORB'] = False
			elif argtarget == '-BRISK':
				if argval == 'Y' or argval == 'y':
					params['BRISK'] = True
				else:
					params['BRISK'] = False
			elif argtarget == '-mask':
				params['mask'] = argval
			elif argtarget == '-erode':
				params['erosion'] = int(argval)
			elif argtarget == '-BRISKcfg':
				params['BRISKcfg'] = argval
			elif argtarget == '-ORBcfg':
				params['ORBcfg'] = argval
			elif argtarget == '-SIFTcfg':
				params['SIFTcfg'] = argval
			elif argtarget == '-SURFcfg':
				params['SURFcfg'] = argval
			elif argtarget == '-bmeth':
				params['bmeth'] = argval
			elif argtarget == '-bkernel':
				params['bkernel'] = int(argval)
			elif argtarget == '-imgsrc':
				params['imgsrc'] = argval
			elif argtarget == '-epsilon':
				params['epsilon'] = float(argval)
			elif argtarget == '-max':
				if argval == 'inf':									#  Admit everything, omit nothing
					params['max'] = float('inf')
				else:
					params['max'] = int(argval)
				if params['max'] <= 0:
					params['max'] = 1
			elif argtarget == '-h':
				params['header'] = argval
			else:
				params['snapshots'].append( int(argval) )

	return params

def usage():
	print('Usage:  python make_signature.py object-name snapshot-number <options, each preceded by a flag>"')
	print(' e.g.:  python make_signature.py big_switch 0 -v -showFeatures -erode 5')
	print('        python make_signature.py control_panel 0 1 2 3 -v -showFeatures -erode 5')
	print('        python make_signature.py control_panel 270 -imgsrc transformed -erode 5')
	print('Flags:  -SIFT         following argument is Y or N, enabling and disabling SIFT detection respectively.')
	print('        -SURF         following argument is Y or N, enabling and disabling SURF detection respectively.')
	print('        -ORB          following argument is Y or N, enabling and disabling ORB detection respectively.')
	print('        -BRISK        following argument is Y or N, enabling and disabling BRISK detection respectively.')
	print('        -imgsrc       following argument is a string indicating the folder containing the source images')
	print('        -BRISKcfg     following argument is a file path to a (binary) BRISK configuration file.')
	print('        -ORBcfg       following argument is a file path to a (binary) ORB configuration file.')
	print('        -SIFTcfg      following argument is a file path to a (binary) SIFT configuration file.')
	print('        -SURFcfg      following argument is a file path to a (binary) SURF configuration file.')
	print('        -mask         following argument is a file path to an optional mask image.')
	print('        -erode        following int argument sets the number of pixels by which to erode the unmasked edge.')
	print('                      (Readme explains when this would be appropriate.)')
	print('        -bmeth        following argument is a string indicating which blur method to use on the query image.')
	print('                      {GAUSS, BOX, MED} BOX is default.')
	print('        -bkernel      following argument is the size of the blur filter. Default is 0 = no blur.')
	print('        -epsilon      following argument sets the Euclidean distance within which features are collpased.')
	print('                      Within an epsilon-ball, the feature point with the strongest response reamins.')
	print('        -max          following argument is the maximum number of features to keep.')
	print('                      Features with the strongest responses are kept.')
	print('        -h            following argument is a text file with copy for the .3df file header.')
	print('        -v            enable verbosity')
	print('        -?')
	print('        -help')
	print('        --help        displays this message.')
	return

if __name__ == '__main__':
	main()
